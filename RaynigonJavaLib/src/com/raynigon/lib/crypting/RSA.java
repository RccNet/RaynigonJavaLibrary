package com.raynigon.lib.crypting;

import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.Cipher;

import org.apache.commons.codec.binary.Base64;


/**Generated on 09.09.2015 by Simon Schneider in Project <b>RaynigonJavaLib</b><p>
 * The RSA Crypter can de- and encrypt RSA, the RSA Keys can be generated by this class,
 * or can be set with the setters
 * @author Simon Schneider
 */
public class RSA implements Crypter{
	
	/** 512 bit Key Size
	 */
	public static final int RSA_KEY_SIZE_512 = 512;
	
	/** 1024 bit Key Size
	 */
	public static final int RSA_KEY_SIZE_1024 = 1024;
	
	/** 2048 bit Key Size
	 */
	public static final int RSA_KEY_SIZE_2048 = 2048;
	
	/** 4096 bit Key Size
	 */
	public static final int RSA_KEY_SIZE_4096 = 4096;
	
	
	
	private PrivateKey privatekey = null;
	private PublicKey my_publickey = null;
	private PublicKey others_publickey = null;
	private Cipher ecipher = null;
	private Cipher dcipher = null;
	
	private int key_size = RSA_KEY_SIZE_1024;
	
	/** Generates a new instance with the default KeySize of 1024 bit
	 * @throws CryptingException	is thrown if an error during initialization occurs
	 */
	public RSA() throws CryptingException{
		try {
			ecipher = Cipher.getInstance("RSA/ECB/NoPadding");     
			dcipher = Cipher.getInstance("RSA/ECB/NoPadding");
		} catch (Exception e) {
			throw new CryptingException("RSA cipher creation", e);
		}
	}
	
	/** Generates a new instance, the KeySize can be chosen from the following:
	 * <ul>
	 * <li>{@link RSA#RSA_KEY_SIZE_512}</li>
	 * <li>{@link RSA#RSA_KEY_SIZE_1024}</li>
	 * <li>{@link RSA#RSA_KEY_SIZE_2048}</li>
	 * <li>{@link RSA#RSA_KEY_SIZE_4096}</li>
	 * </ul>
	 * @param inKeySize the KeySize chosen from the list above
	 * @throws CryptingException	is thrown if an error during initialization occurs
	 */
	public RSA(int inKeySize) throws CryptingException{
		this();
		switch(inKeySize){
		case 512:
		case 1024:
		case 2048:
		case 4096:
			key_size = inKeySize;
		break;
		default:
			throw new CryptingException("Undefined KeySize was used");
		}
	}
	
	/** Generates a new RSA Public/Private Key Pair and returns the public key.
	 * The private key is stored inside the Object and will be overridden on the next method call.
	 * @return	the generated public key
	 * @throws NoSuchAlgorithmException		Should not occur, if so, the JVM has no RSA de- and encryption available.
	 */
	public PublicKey generatePair() throws NoSuchAlgorithmException{
		KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA");
        kpg.initialize(key_size);
		KeyPair kp = kpg.generateKeyPair(); 
		privatekey = kp.getPrivate();
		my_publickey = kp.getPublic();
		return my_publickey;
	}
	
	/** Returns the generated Public Key
	 * @return	the generated Public key
	 */
	public PublicKey getOwnPublicKey(){
		return my_publickey;
	}
	
	/**Returns the Public Key set with the setter {@link RSA#setOtherPublicKey(PublicKey)}
	 * @return	the Public Key set with the setter {@link RSA#setOtherPublicKey(PublicKey)}
	 */
	public PublicKey getOtherPublicKey(){
		return others_publickey;
	}

	/** Sets the public key, needed for encryption
	 * @param others	the public key of the decrypting instance
	 */
	public void setOtherPublicKey(PublicKey others){
		others_publickey = others;
	}
	
	/** Sets the public key, needed for encryption
	 * @param otherskey 	the public key of the decrypting instance
	 * @throws CryptingException 	occurs if the key was`nt formated in the right was
	 */
	public void setOtherPublicKey(String otherskey) throws CryptingException{
		try {
			KeyFactory keyFactory = KeyFactory.getInstance("RSA");
		    X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(Base64.decodeBase64(otherskey));
		    others_publickey = keyFactory.generatePublic(publicKeySpec);
		} catch (Exception e) {
			throw new CryptingException("RSA key reading", e);
		}
	}
	
	/** Sets the public key, needed for encryption
	 * @param otherskey the public key of the decrypting instance
	 * @throws CryptingException 		occurs if the key was`nt formated in the right was
	 */
	public void setOtherPublicKey(byte[] otherskey) throws CryptingException{
		try {
			KeyFactory keyFactory = KeyFactory.getInstance("RSA");
			X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(otherskey);
		    others_publickey = keyFactory.generatePublic(pubKeySpec);
		} catch (Exception e) {
			throw new CryptingException("RSA key reading", e);
		}
	}
	
	@Override
    public byte[] encrypt(byte[] data) throws CryptingException{
        try {
        	ecipher.init(Cipher.ENCRYPT_MODE, others_publickey);
            return ecipher.doFinal(data);
		} catch (Exception e) {
			throw new CryptingException("RSA encryption", e);
		}
    }
    
	@Override
    public byte[] decrypt(byte[] cdata) throws CryptingException{
    	try {
    		dcipher.init(Cipher.DECRYPT_MODE, privatekey);
            return dcipher.doFinal(cdata);
		} catch (Exception e) {
			throw new CryptingException("RSA decryption", e);
		}
    }
}
